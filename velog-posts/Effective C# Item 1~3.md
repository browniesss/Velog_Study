<p>Effective C# Chapter 1(C# 언어요소) 내용 중 Item 1 ~ 3 항목을 정리한 글입니다.
<img height="25%" src="https://velog.velcdn.com/images/kl45678/post/3e98c70c-e754-4b1f-9dd6-4302d59e2679/image.png" width="25%" /></p>
<h3 id="아이템-1--지역변수를-선언할-때는-var를-사용하는-것이-낫다">아이템 1 : 지역변수를 선언할 때는 var를 사용하는 것이 낫다.</h3>
<ul>
<li>지역변수의 타입은 암시적으로 선언해두는 것이 좋다.</li>
<li>일부 쿼리 구문의 경우 iEnumerable&lt; T&gt;를 반환하는 경우도 있지만, IQueryable&lt; T&gt;를 반환하기도 하는데, 정확한 반환 타입을 알지 못한 채 올바르지 못한 타입을 명시적으로 정하게 된다면 득보다 실이 많다.<ul>
<li>예를 들어 IQueryable&lt; T&gt; 컬렉션을 IEnumerable&lt; T&gt;로 강제 형 변환하게 되면 IQueryProvider가 제공하는 장점을 모두 잃게 된다.</li>
</ul>
</li>
<li>var을 사용하여 암시적으로 변수를 선언한 코드가 더 잘 읽힌다.</li>
</ul>
<h4 id="참고할-점">참고할 점</h4>
<ul>
<li>var을 사용하는건 동적 타이핑이 아니다. (C#의 정적 타이핑임)<ul>
<li>동적 타이핑처럼 보이나, 할당 연산자 오른쪽 타입을 확인하여 왼쪽 변수 타입을 결정하게 하는 것 (<strong>컴파일 시점</strong>)</li>
</ul>
</li>
<li>내장 숫자 타입(int, float, double 등)을 선언할 때는 var 대신 명시적으로 타입을 선언하는 편이 낫다.<ul>
<li>형 변환 과정에서 정밀도에 손실이 발생할 수 있기 때문</li>
</ul>
</li>
<li>var 사용 시 변환되는 형태가 어느정도 예측은 가도록 가독성이 있게 작성 필요<pre><code>var thing = AccountFactory.CreateSavingsAccount(); // Account가 반환되겠구나, 예측 가능
var result = someObject.DoSomeWork(anotherParams); // 어느 값이 반환되는지 예측이 불가능</code></pre></li>
</ul>
<h3 id="아이템-2--const보다는-readonly가-좋다">아이템 2 : const보다는 readonly가 좋다</h3>
<ul>
<li><p>const : 컴파일 타임 상수</p>
</li>
<li><p>readonly : 런타임 상수 readonly : 런타임 상수</p>
</li>
<li><p>컴파일 타임 상수가 성능상 약간 더 빠르긴 하지만, 런타임 상수에 비해 유연성이 상당히 떨어진다.</p>
<ul>
<li>컴파일 타임 상수는 내장된 숫자형, enum, 문자열, null에 대해서만 사용이 가능하다(내장 자료형이어야만 컴파일타임에 상수를 리터럴로 대체가 가능하기 때문)<pre><code>private const DateTime classCreation = new DataTime(2000, 1, 1, 0, 0, 0); // 컴파일 실패</code></pre></li>
<li>런타임 상수는 생성자에서 초기화 될 수 있으며, 어떤 타입과도 사용될 수 있다. 또한 생성자를 통해서도 초기화가 가능하다.</li>
</ul>
</li>
<li><p>결론은, 컴파일할 때 사용되는 상숫값(거의 수정되지 않는)들을 정의할때는 const를 사용하고, 이외에는 readonly를 사용하는게 좋다.</p>
</li>
</ul>
<h3 id="아이템-3--캐스트보다는-is-as가-좋다">아이템 3 : 캐스트보다는 is, as가 좋다</h3>
<p>C#은 <strong>정적 타이핑을 수행하는 언어</strong>다. 따라서 타입 불일치가 발생해도 컴파일 타임에서 걸러주기 때문에, 런타임에 타입 검사를 자주 수행할 필요가 없지만, 간혹 런타임에 반드시 타입을 확인해야 하는 경우도 있다.
형 변환을 수행하는 경우 캐스팅을 사용하기보다 as 연산자를 사용하는 것이 좋다. as를 사용하는게 더 안전하기도 하거니와 런타임에 더 효율적으로 동작하기 때문이다. 다만 as나 is 연산자를 사용하면 사용자 정의 형변환은 수행되지 않는다.</p>
<h4 id="as-is">AS IS</h4>
<ul>
<li>AS나 IS 연산자는 런타임에 객체의 타입을 확인하고 필요에 따라 박싱을 수행하는 것을 제외하고는 어떠한 작업도 수행하지 않는다.</li>
<li>AS 연산자는 형변환을 수행할 수 없거나, null을 대상으로 형변환을 수행하는 경우 null을 반환한다. (캐스팅은 null 확인 코드와 예외 처리 코드가 모두 필요하지만, as 연산자는 null 확인 코드만 있으면 된다)</li>
<li>참조 타입 간 형 변환만 가능하다.(값 타입은 불가능)</li>
</ul>
<h4 id="캐스팅-연산자">캐스팅 연산자</h4>
<ul>
<li>사용자 정의 형변환 연산자는 객체의 런타임 타입이 아닌 컴파일 타임의 타입에 맞춰서 수행된다. </li>
<li>형변환 연산자가 개입될 수 있다. (숫자 타입에 대한 형변환 연산자 등)</li>
</ul>